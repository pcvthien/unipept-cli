#!usr/bin/env ruby

require 'cri'
require 'typhoeus'
require 'yaml'
require 'json'
require 'fileutils'

require_relative '../lib/unipept'

Signal.trap("PIPE", "EXIT")
Signal.trap("INT", "EXIT")
class ApiRunner < Cri::CommandRunner

  def initialize(args, opts, cmd)
    super
    @configuration = Unipept::Configuration.new
    host = @configuration['host']
    if host.nil? || host.empty?
      puts "WARNING: no host has been set, you can set the host with `unipept config host http://localhost:3000/`"
      exit 1
    end
    if !host.start_with? "http://"
      host = "http://#{host}"
    end

    @url = "#{host}/api/v1/#{mapping[cmd.name]}.json"
    @message_url = "#{host}/api/v1/messages.json"
  end


  def mapping
    {'pept2taxa' => 'pept2taxa', 'pept2lca' => 'pept2lca'}
  end

  def input_iterator
    if options[:input]
       File.readlines(options[:input]).each
    else
      STDIN.each_line
    end
  end

  def batch_size
    100
  end

  def url_options(sub_part)
    filter = options[:select] ? options[:select] : []
    if filter.empty?
      names = true
    else
      names = filter.any? {|f| /.*name.*/.match f}
    end
    {:input => sub_part,
     :equate_il => options[:equate],
     :extra => options[:extra],
     :names => names,
    }
  end

  def get_server_message
    return if options[:quiet]
    return unless STDOUT.tty?
    last_fetched = @configuration['last_fetch_date']
    if last_fetched.nil? || (last_fetched + 60 * 60 * 24) < Time.now
      version = File.read(File.join(File.dirname(__FILE__), "..", "VERSION"))
      puts Typhoeus.get(@message_url, params: {version: version}).body

      @configuration['last_fetch_date'] = Time.now
      @configuration.save
    end
  end

  def run
    get_server_message

    formatter = Unipept::Formatter.new_for_format(options[:format])
    peptides = input_iterator

    filter_list = options[:select] ? options[:select] : []
    filter_list = filter_list.map {|f| glob_to_regex(f) }
    output = STDOUT.tty? ? STDOUT : STDERR

    batch_order = Unipept::BatchOrder.new

    printed_header = false
    result = []

    hydra = Typhoeus::Hydra.new(max_concurrency: 20)
    num_req = 0

    peptide_iterator(peptides) do |sub_division, i|
      request = Typhoeus::Request.new(
        @url,
        method: :post,
        body: url_options(sub_division)
      )
      request.on_complete do |resp|
        if resp.timed_out?
          $stderr.puts "request timed out, continuing anyway, but results might be incomplete"
        else
          if resp.success?
            # if JSON parsing goes wrong
            sub_result = JSON[resp.response_body] rescue []
            sub_result = [sub_result] if not sub_result.kind_of? Array

            sub_result.map! {|r| r.select! {|k,v| filter_list.any? {|f| f.match k } } } if ! filter_list.empty?

            result << sub_result

            # wait till it's our turn to write
            batch_order.wait(i) do
              if ! sub_result.empty?
                if ! printed_header
                  write_to_output formatter.header(sub_result)
                  printed_header = true
                end
                write_to_output formatter.format(sub_result)
              end
            end
          else
            path = File.expand_path(File.join(Dir.home, "unipept.log"))
            File.open(path, "w") do |f|
              f.write resp.response_body
            end
            $stderr.puts "API request failed! log can be found in #{path}"
          end
        end
      end
      hydra.queue request

      num_req += 1
      if num_req % 200 == 0
        hydra.run
      end

    end

    hydra.run


    begin
      download_xml(result)
    rescue
      STDERR.puts "Something went wrong while downloading xml information! please check the output"
    end

  end

  def write_to_output(string)
    if options[:output]
      File.open(options[:output], 'a') do |f|
        f.write string
      end
    else
      puts string
    end
  end


  def download_xml(result)
    if options[:xml]
      File.open(options[:xml] + ".xml", "wb") do |f|
        f.write Typhoeus.get("http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=taxonomy&id=#{result.first.map{|h| h['taxon_id'] }.join(",")}&retmode=xml").response_body
      end
    end
  end

  def peptide_iterator(peptides, &block)
    peptides.each_slice(batch_size).with_index(&block)
  end

  private

  def glob_to_regex(glob_string)
    # only implement * -> . for now
    Regexp.new glob_string.gsub("*", ".*")
  end
end

class Taxa2lca < ApiRunner

  def mapping
    {"taxa2lca" => "taxa2lca"}
  end

  def peptide_iterator(peptides, &block)
    block.call(peptides.to_a, 0)
  end

  def batch_size
    raise "NOT NEEDED FOR TAXA2LCA"
  end

end

class Pept2prot < ApiRunner

  def mapping
    {"pept2prot" => "pept2prot"}
  end

  def download_xml(result)
    if options[:xml]
      FileUtils.mkdir_p(options[:xml])
      result.first.each do |prot|
        File.open(options[:xml] + "/#{prot['uniprot_id']}.xml", "wb") do |f|
          f.write Typhoeus.get("http://www.uniprot.org/uniprot/#{prot['uniprot_id']}.xml").response_body
        end
      end
    end
  end

  def batch_size
    10
  end

end

root_cmd = Cri::Command.new_basic_root.modify do
  name 'unipept'
  flag :v, :version, "print version"
  flag :q, :quiet, "don't show update messages"
  option :i, :input, "input file", :argument => :required
  option :o, :output, "output file", :argument => :required
  option :f, :format, "output format (available: #{Unipept::Formatter.available.join "," }) (default: #{Unipept::Formatter.default})", :argument => :required

  run do |opts, args, cmd|
    if opts[:version]
      puts File.read(File.join(File.dirname(__FILE__), "..", "VERSION"))
    end
  end
end

root_cmd.define_command('config') do
  usage 'config attr [value]'

  run do |opts, args, cmd|
    config = Unipept::Configuration.new
    if args.size > 1
      config[args.first] = args[1]
      config.save
    elsif args.size == 1
      puts config[args.first]
    end
  end

end

root_cmd.define_command('pept2taxa') do
  usage       'pept2taxa [options]'
  aliases     :s
  summary     'Single Peptide Search'
  description 'Search Unipept for the given peptide and return taxons'

  flag :e, :equate, "equate I and L"
  option :s, :select, "select the attributes", :argument => :required, :multiple => true
  option :a, :extra, "Show full lineage"
  option :x, :xml, "Download taxonomy from NCBI as xml (specify output filename)", :argument => :required

  runner ApiRunner
end

root_cmd.define_command('pept2lca') do
  usage       'pept2lca [options]'
  aliases     :l
  summary     'Give lowest common ancestor for given peptide'
  description 'Search Unipept for the given peptide and return the lowest common ancestor'

  flag :e, :equate, "equate I and L"
  option :s, :select, "select the attributes", :argument => :required, :multiple => true
  option :a, :extra, "Show full lineage"

  runner ApiRunner
end

root_cmd.define_command('taxa2lca') do
  usage       'taxa2lca [options]'
  aliases     :t
  summary     'Give lowest common ancestor for taxon ids'
  description 'Search Unipept for the given taxon ids and return the lowest common ancestor'

  option :s, :select, "select the attributes", :argument => :required, :multiple => true
  option :a, :extra, "Show full lineage"

  runner Taxa2lca
end

root_cmd.define_command('pept2prot') do
  usage       'pept2prot [options]'
  aliases     :p
  summary     'Give protein information for given peptides'
  description 'Search Unipept for the given peptides and return the lowest common ancestor'

  flag :e, :equate, "equate I and L"
  option :s, :select, "select the attributes", :argument => :required, :multiple => true
  option :x, :xml, "download uniprot record in specified directory", :argument => :required
  flag :a, :extra, "include all information. WARNING: will take much longer!"

  runner Pept2prot
end

root_cmd.run(ARGV)
